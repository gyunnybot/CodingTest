# IEEE-754 표준 부동소수점 방식에서 Float의 Bias가 127인 이유

IEEE-754 표준 부동소수점 방식에서 **float의 bias가 127**인 이유는 **지수부(exponent)의 표현 범위를 효율적으로 나타내기 위해서**입니다. 이를 이해하려면 몇 가지 개념을 짚고 넘어가야 합니다.

---

## 1. 지수부의 크기와 표현 방식
IEEE-754 표준의 float는 다음과 같이 구성됩니다:
- **부호 비트 (1비트)**: 양수(0) 또는 음수(1)를 나타냄
- **지수부 (8비트)**: 실수의 지수를 나타냄
- **가수부 (23비트)**: 정규화된 수의 유효 숫자를 저장

지수부는 **8비트**로 표현되므로, 가능한 값의 범위는 다음과 같습니다:
\[
0 ~ 255
\]

하지만, 지수는 **양수와 음수 모두**를 표현해야 하므로, 이를 위해 **Bias(바이어스)**를 추가로 사용합니다.

---

## 2. Bias의 역할
Bias는 지수부를 비트로 표현할 때 **음수 대신 모두 양수로 변환**하기 위한 값입니다. 예를 들어, float에서 표현하려는 실제 지수 E는 다음 공식을 통해 저장됩니다.

\[
E = e - Bias
\]

- e: 지수부에 저장되는 값(0~255 사이의 값)
- Bias: 기준 값(127)

즉, 저장된 값 e에서 127을 빼야 실제 지수 E를 얻을 수 있습니다.

---

## 3. Bias 값이 127인 이유
지수의 실제 표현 범위는 다음과 같습니다:
- 지수부 e는 8비트로 표현되므로 e = 0 ~ 255
- 실제 지수 E는 E = e - 127 공식을 따릅니다.

따라서, 실제 지수 E의 범위는:
\[
-127 ~ 128
\]

이 범위는 **부동소수점의 표현 목적(양수, 음수, 아주 작은 값, 아주 큰 값 등)**을 만족하기에 적합합니다.

- **127이라는 값은 중간값**에 해당하며, 이 값을 Bias로 설정하면 지수의 범위를 균형 있게 음수와 양수로 나눌 수 있습니다.
- 2^8 = 256에서 -127 ~ 128 사이를 양수/음수로 공평하게 분배합니다.

---

## 4. Bias가 128이어야 한다는 의문에 대한 답변
8비트로 표현할 수 있는 수의 범위는 다음과 같습니다:
- **부호 있는 정수**: -128 ~ 127 (2의 보수 방식)
- **부호 없는 정수**: 0 ~ 255

IEEE-754의 지수부는 **부호 없는 정수(unsigned integer)**로 저장됩니다. 즉, 음수를 표현하지 않으며, 음수 지수를 나타내기 위해 **bias를 사용**합니다.

만약 bias가 128이었다면, 실제 지수 E의 범위는:
\[
E = e - 128
\]

- e = 0일 때, E = -128
- e = 255일 때, E = 127

이 경우 지수 범위가 -128 ~ 127로 설정됩니다. 그러나, IEEE 754는 다음과 같은 이유로 **bias를 127로 설정**했습니다:

1. **양수 지수 범위를 넓히기 위해**:
    - 과학적 표기법에서는 아주 큰 수(양의 지수)를 더 자주 사용하는 경향이 있습니다.
    - 부동소수점 표현에서 양수 지수는 주로 큰 숫자를 나타내므로, 양의 지수 범위를 하나 더 넓게 확보하는 것이 더 유리합니다.
2. **표현의 균형**:
    - -127 ~ 128로 표현하면 음수와 양수를 거의 균형 있게 나눌 수 있습니다.

결론적으로, **bias가 128이었다면 음수와 양수 범위가 불균형**해졌을 것입니다.

---

## 5. 요약
- 지수부 e는 **0~255**의 부호 없는 정수로 저장됩니다.
- 실제 지수 E는 E = e - 127로 계산되며, 범위는 -127 ~ 128입니다.
- Bias가 127인 이유는 양수와 음수를 균형 있게 나누면서도 양의 지수 범위를 더 넓게 확보하기 위함입니다.

---

## 6. 알아두면 좋은 공식

1. **10진수 실수를 2진수로 바꾸는 공식**:

    10진수 실수를 2진수로 바꿀 때는 정수부와 소수부를 따로 계산 후 합칩니다.
    
    예를 들어 10진수 실수 -6.25에서 정수부 6는 110(2)로 나타낼 수 있습니다. 이어서 남은 소수부 0.25가 정수 1이 될 때까지 2씩 곱합니다. 이후, 결과값의 정수 부분만을 아래서부터 차례로 저장한 후 연산값에서 뺍니다.

    -6.25의 경우 소수부는 0.25이고
    0.25 x 2 = 0.5 -> 0
    0.5 x 2 = 1 -> 1

    따라서, 10진수 실수 -6.25는 2진수 -110.01로 나타낼 수 있습니다.

    bias 계산을 위해서는 정수부를 한 자릿수로 변경해야 합니다. 그러므로 최종 변환 값은 -1.1001 x 2^2가 됩니다.

2. **bias = 2^(자료형에 따른 지수부의 최대 비트 - 1) - 1**:

    10진수 -6.25는 2진수 -1.1001 x 2^2로 나타낼 수 있습니다. float 자료형에 수를 저장한다면, sign 비트에는 1, exponent 비트에는 `bias(2^(8-1)-1) + 2의 지수(2) = 129`를 unsigned type 10000001로 저장합니다.

    마지막으로 fraction 비트에는 2진수의 **소수 부분**부터 시작해 순서대로 자리를 채우고 남은 공간은 0으로 완성합니다.

        1(1) 10000001(8) 1001 0000 0000 0000 0000 000(23)

    가수부(fraction)는 유효 숫자를 표현하므로 10진법의 수로 치환했을 때 약 2^23 ~= 10^(6)까지 정확도를 유지할 수 있습니다. 그래서 float의 유효숫자는 6자리인 것입니다.

    같은 논리로 double의 경우 가수부가 52비트로 구성되므로 2^52 ~= 10^(15), 유효 숫자는 15자리입니다.