# Call-by-Value, Call-by-Reference

## Call-by-Value

### 설명
- **단순한 변수, 구조체, STL 객체** 등을 함수의 인자로 넘길 때에는 **값이 복사**되어 함수에 전달됩니다.
- 이 복사는 원본 데이터를 기반으로 **새로운 복사본**을 생성하기 때문에, 함수 내부에서 복사본이 변경되더라도 **원본 데이터는 영향을 받지 않습니다.**

### 특징
- 원본 데이터를 보호할 수 있습니다.
- 함수 호출 시 전달 비용이 발생합니다. (특히, 구조체나 STL 객체처럼 크기가 큰 경우)

---

## Call-by-Reference

### 설명
- **배열**이나 **포인터, 참조자를 활용한 변수** 등을 함수 인자로 넘길 때, 함수는 **원본 데이터의 메모리 주소를 참조**합니다.
- 따라서 함수 내부에서 해당 데이터에 직접 접근하며, **원본 데이터가 변경될 수 있습니다.**

### 특징
- 복사가 이루어지지 않으므로, 메모리와 시간 면에서 효율적입니다.
- 원본 데이터를 보호하려면 `const` 키워드를 사용하여 읽기 전용 참조로 전달해야 합니다.

---

## 추가로 확인할 점

### 1. 배열은 항상 Call-by-Reference처럼 동작
- 배열을 함수로 전달할 때는 배열의 첫 번째 요소의 주소가 전달됩니다.
- 배열의 크기 정보는 전달되지 않으므로, 크기를 별도로 인자로 넘겨야 합니다.

### 2. STL 객체(Call-by-Value vs Call-by-Reference)
- STL 객체(예: `std::vector`, `std::string`)를 Call-by-Value(default)로 넘기면 데이터 복사가 이루어져 성능에 영향을 줄 수 있습니다.
- 복사를 방지하려면 **참조자(`&`)** 또는 **포인터(`*`)** 를 사용하여 전달하는 것이 좋습니다.

### 3. 참조를 사용할 때 주의
- 원본 데이터의 변경을 원치 않을 경우 **`const` 키워드**를 사용하여 함수 내부에서 수정되지 않도록 명시적으로 보호하세요.

```cpp
void readOnlyFunction(const int& value) {
    // value는 읽기 전용으로 접근 가능
    // value = 10;  // 컴파일 에러 발생
}
```